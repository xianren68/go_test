## 复合数据类型
### 数组
go数组是值类型，不怎么会用，一般用slice
go值类型都会有初值，数组的初值根据是什么类型的数组来决定，定义后会用定义类型的初值来填充
例如int数组，初值全为0,string类型，初值全为""
`[...]int{1,2,3}`可以用省略号代表长度，通过后面初始化的值来判断具体长度
还可以指定索引来给值
`[...]{99:-1}` 一个长度为100的数组，前面都为0，最后一位为-1
不同长度的数组是不同类型，可以用==直接比较两个数组是否相等

### slice
可以将其看作一个长度可变的数组，它有指针指向一个底层数组
通过用`slice = arr[start:end]`来从其他数组或切片中截取一部分,这个部分是左闭右开`:`前面省略代表从0开始
后面省略则为直到最后一位，两边都省略，则是包含所有元素
可以像数组一样创建，只不过不用写长度`[]int{}`,但我们通常用make函数创建
`make([]T,len,cap)` len为切片长度，cap为切片容量，cap可以省略，若省略，则cap==len
make函数会自动创建一个底层的数组，并引用它
内置函数 `len(),cap()`,分别对应长度与容量
**长度就是切片本身的长度，容量则是切片在底层数组中的第一个位置，到底层数组的末位的长度**
###### 例如：
如果切片底层数组为`arr = [1,2,3,4,5,6]` ,切片`a=[2:5]` 则`len(a)=3`，包括2，3，4这三个位置
`cap(a)=4`
```
func main() {
	arr := [...]int{1, 2, 3, 4, 5, 6}
	slice := arr[2:5]
	fmt.Println(len(slice), cap(slice)) // 3 4
}
```
切片不能直接用 == 比较
切片本质上是一个引用类型，0值为nil,判断切片是否为空，应该从长度判断，而不是看其是否nil
内置函数`append(slice,value/slice)`,用于往切片中追加元素，**追加**，是直接从切片长度开始的
```
func main() {
	slice := make([]int, 3, 6)
	fmt.Println(slice, len(slice)) // [0 0 0] 3
	slice = append(slice, 7)
	fmt.Println(slice, len(slice)) // [0 0 0 7] 4
}
```
如上例，就算前面没有手动赋值，append也是从末位加了一位
append函数如果追加的长度超过了容量，则底层数组会扩容，slice也会指向扩容后的底层数组
所以在使用append的时候注意**地址的变化**
```
func main() {
	slice := make([]int, 3, 6)
	fmt.Printf("值:%v 长度：%d 容量：%d 地址：%p\n", slice, len(slice), cap(slice), slice) // [0 0 0] 3
	slice = append(slice, 5, 6, 7, 8, 10)
	fmt.Printf("值:%v 长度：%d 容量：%d 地址：%p\n", slice, len(slice), cap(slice), slice)
}

// 值:[0 0 0] 长度：3 容量：6 地址：0xc00000e360
// 值:[0 0 0 5 6 7 8 10] 长度：8 容量：12 地址：0xc000062060
```
底层数组的扩容一般是*2来扩容的，如上6>>12，不过并不一定，所以一般用原先的变量接append的返回值
内置函数`copy(target,origin)` 从origin中将元素按顺序复制到target中，返回成功复制的个数，为二者长度的最小值，所以不用担心溢出
```
func main() {
	slice := []int{1, 2, 3, 4, 5, 6}
	s1 := slice[2:4]
	copy(s1, slice[3:6])
	fmt.Println(s1, slice) // [4 5] [1 2 4 5 5 6]

}
```

